<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JSON Attribute Inspector</title>
  <style>
    body {
      margin: 0;
      padding: 16px;
      font-family: 'Inter', system-ui, sans-serif;
      font-size: 12px;
      background: #ffffff;
    }
    
    .container {
      width: 100%;
      max-width: 350px;
    }
    
    h2 {
      margin: 0 0 16px 0;
      font-size: 14px;
      font-weight: 600;
      color: #333;
    }
    
    .section {
      margin-bottom: 20px;
    }
    
    label {
      display: block;
      margin-bottom: 6px;
      font-size: 11px;
      font-weight: 500;
      color: #666;
    }
    
    textarea {
      width: 100%;
      height: 120px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 11px;
      resize: vertical;
      box-sizing: border-box;
    }
    
    textarea:focus {
      outline: none;
      border-color: #18a0fb;
      box-shadow: 0 0 0 2px rgba(24, 160, 251, 0.2);
    }
    
    button {
      background: #18a0fb;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 16px;
      font-size: 12px;
      cursor: pointer;
      width: 100%;
      font-weight: 500;
    }
    
    button:hover {
      background: #0d8ce8;
    }
    
    button:active {
      background: #0b7dd1;
    }
    
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    select {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 12px;
      background: white;
      cursor: pointer;
      box-sizing: border-box;
      max-height: 200px;
    }
    
    select:focus {
      outline: none;
      border-color: #18a0fb;
      box-shadow: 0 0 0 2px rgba(24, 160, 251, 0.2);
    }
    
    optgroup {
      font-weight: 600;
      font-size: 11px;
      color: #666;
      background: #f8f9fa;
      padding: 4px 0;
    }
    
    optgroup option {
      font-weight: 400;
      color: #333;
      padding-left: 12px;
      background: white;
    }
    
    .stats {
      font-size: 10px;
      color: #999;
      margin-top: 8px;
      padding: 6px 8px;
      background: #f8f9fa;
      border-radius: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .error {
      color: #e74c3c;
      font-size: 11px;
      margin-top: 6px;
      font-style: italic;
    }
    
    .success {
      color: #27ae60;
      font-size: 11px;
      margin-top: 6px;
      font-style: italic;
    }
    
    .attributes-section {
      display: none;
    }
    
    .attributes-section.show {
      display: block;
    }
    
    /* Tab System */
    .tab-nav {
      display: flex;
      margin-bottom: 20px;
      border-bottom: 1px solid #ddd;
    }
    
    .tab-button {
      background: none;
      border: none;
      padding: 12px 20px;
      font-size: 12px;
      font-weight: 500;
      color: #666;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s ease;
      width: auto;
    }
    
    .tab-button:hover {
      background: #f8f9fa;
      color: #333;
    }
    
    .tab-button.active {
      color: #18a0fb;
      border-bottom-color: #18a0fb;
      background: none;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .target-selection {
      margin-bottom: 12px;
    }
    
    /* Attributes Cards */
    .attributes-cards {
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #e1e5e9;
      border-radius: 8px;
      background: #fafbfc;
    }
    
    .attribute-card {
      padding: 12px 16px;
      border-bottom: 1px solid #e1e5e9;
      background: white;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }
    
    .attribute-card:last-child {
      border-bottom: none;
    }
    
    .attribute-card:hover {
      background: #f8f9fa;
      border-left: 4px solid #18a0fb;
      padding-left: 12px;
    }
    
    .attribute-card.selected {
      background: #e8f4fd;
      border-left: 4px solid #18a0fb;
      padding-left: 12px;
    }
    
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 4px;
    }
    
    .card-category {
      font-size: 10px;
      font-weight: 500;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .card-type {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 500;
      text-transform: lowercase;
    }
    
    .type-string {
      background: #e3f2fd;
      color: #1976d2;
    }
    
    .type-number {
      background: #f3e5f5;
      color: #7b1fa2;
    }
    
    .type-boolean {
      background: #e8f5e8;
      color: #388e3c;
    }
    
    .type-object {
      background: #fff3e0;
      color: #f57c00;
    }
    
    .type-array {
      background: #fce4ec;
      color: #c2185b;
    }
    
    .card-path {
      font-size: 12px;
      font-weight: 600;
      color: #333;
      margin-bottom: 4px;
      font-family: 'Monaco', 'Menlo', monospace;
    }
    
    .card-value {
      font-size: 11px;
      color: #666;
      line-height: 1.4;
      word-break: break-all;
    }
    
    .search-controls {
      position: sticky;
      top: 0;
      background: white;
      z-index: 10;
      padding-bottom: 8px;
    }
    
    /* Array Group Cards */
    .array-group-card {
      border-left: 4px solid #c2185b;
      padding-left: 12px;
    }
    
    .array-properties {
      margin-top: 8px;
      padding: 8px;
      background: #fafbfc;
      border-radius: 4px;
      border: 1px solid #e1e5e9;
    }
    
    .array-property {
      padding: 6px 8px;
      margin-bottom: 4px;
      background: white;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid transparent;
    }
    
    .array-property:last-child {
      margin-bottom: 0;
    }
    
    .array-property:hover {
      background: #f0f8ff;
      border-color: #18a0fb;
    }
    
    .array-property.selected {
      background: #e8f4fd;
      border-color: #18a0fb;
      box-shadow: 0 0 0 1px #18a0fb;
    }
    
    .property-name {
      font-weight: 600;
      font-size: 11px;
      color: #333;
      margin-right: 8px;
    }
    
    .property-value {
      font-size: 11px;
      color: #666;
      font-family: 'Monaco', 'Menlo', monospace;
    }
    
    /* Tab 2 Three Column Layout */
    .mapping-layout {
      display: flex;
      gap: 16px;
      align-items: flex-start;
      margin-bottom: 20px;
      min-height: 300px;
    }
    
    .mapping-column {
      flex: 1;
      background: #fafbfc;
      border: 1px solid #e1e5e9;
      border-radius: 8px;
      padding: 16px;
    }
    
    .column-title {
      margin: 0 0 4px 0;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }
    
    .column-subtitle {
      margin: 0 0 12px 0;
      font-size: 11px;
      color: #666;
    }
    
    .mapping-arrow {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 40px;
      width: 40px;
    }
    
    .arrow-container {
      width: 32px;
      height: 32px;
      background: #18a0fb;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .arrow {
      font-size: 16px;
      color: white;
      font-weight: bold;
    }
    
    .attributes-list, .properties-list {
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #e1e5e9;
      border-radius: 6px;
      background: white;
    }
    
    .empty-state {
      padding: 20px;
      text-align: center;
      color: #999;
      font-size: 11px;
      font-style: italic;
    }
    
    .attribute-item, .property-item {
      padding: 8px 12px;
      border-bottom: 1px solid #f0f0f0;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .attribute-item:last-child, .property-item:last-child {
      border-bottom: none;
    }
    
    .attribute-item:hover, .property-item:hover {
      background: #f8f9fa;
    }
    
    .attribute-item.selected, .property-item.selected {
      background: #e8f4fd;
      border-left: 3px solid #18a0fb;
    }
    
    .item-name {
      font-weight: 600;
      font-size: 11px;
      color: #333;
      font-family: 'Monaco', 'Menlo', monospace;
    }
    
    .item-type {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 500;
      margin-left: 8px;
    }
    
    .item-value {
      font-size: 10px;
      color: #666;
      margin-top: 2px;
      font-family: 'Monaco', 'Menlo', monospace;
    }
    
    .component-selection {
      margin-bottom: 12px;
    }
    
    .component-selection label {
      display: block;
      margin-bottom: 4px;
      font-size: 11px;
      font-weight: 500;
      color: #666;
    }
    
    .compact-select {
      width: 100%;
      padding: 6px 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 11px;
      background: white;
    }
    
    .mapping-actions {
      border-top: 1px solid #e1e5e9;
      padding-top: 16px;
    }
    
    /* Mapping Queue Styles */
    .mapping-queue-section {
      border-top: 1px solid #e1e5e9;
      margin-top: 16px;
      padding-top: 16px;
    }
    
    .mapping-queue {
      border: 1px solid #e1e5e9;
      border-radius: 6px;
      background: #fafbfc;
      min-height: 60px;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .empty-queue {
      padding: 20px;
      text-align: center;
      color: #999;
      font-size: 12px;
      font-style: italic;
    }
    
    .queue-item {
      padding: 8px 12px;
      border-bottom: 1px solid #e1e5e9;
      background: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
    }
    
    .queue-item:last-child {
      border-bottom: none;
    }
    
    .queue-mapping-text {
      flex: 1;
      color: #333;
    }
    
    .queue-remove-btn {
      background: #f24822;
      color: white;
      border: none;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 10px;
      cursor: pointer;
      transition: opacity 0.2s;
    }
    
    .queue-remove-btn:hover {
      opacity: 0.8;
    }
    
    /* New Component-First Layout */
    .component-selection-section {
      margin-bottom: 20px;
      padding: 20px;
      background: #fafbfc;
      border: 1px solid #e1e5e9;
      border-radius: 12px;
    }
    
    .component-selection {
      width: 100%;
    }
    
    .full-width-select {
      width: 100%;
      padding: 12px 40px 12px 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 14px;
      background: white;
      font-weight: 500;
    }
    
    .property-mapping-section {
      padding: 20px 20px 24px 20px;
      background: #fafbfc;
      border: 1px solid #e1e5e9;
      border-radius: 12px;
    }
    
    .property-mappings-list {
      background: white;
      border: 1px solid #e1e5e9;
      border-radius: 6px;
      overflow: hidden;
    }
    
    .property-mapping-row {
      display: flex;
      align-items: center;
      padding: 16px;
      border-bottom: 1px solid #e1e5e9;
      gap: 12px;
      transition: background-color 0.2s;
    }
    
    .property-mapping-row:hover {
      background-color: #f8f9fa;
    }
    
    .property-mapping-row:last-child {
      border-bottom: none;
    }
    
    .property-info {
      flex: 0 0 120px;
      min-width: 0;
    }
    
    .property-name {
      font-weight: 600;
      color: #333;
      font-size: 14px;
      margin-bottom: 4px;
      word-break: break-word;
    }
    
    .property-type {
      font-size: 10px;
      color: #18a0fb;
      text-transform: uppercase;
      font-weight: 600;
      background: #e8f4fd;
      padding: 2px 4px;
      border-radius: 3px;
      display: inline-block;
    }
    
    .property-arrow {
      color: #18a0fb;
      font-size: 16px;
      font-weight: bold;
      user-select: none;
      flex: 0 0 auto;
    }
    
    .attribute-select {
      flex: 1;
      min-width: 0;
      max-width: none;
      padding: 8px 32px 8px 10px;
      border: 2px solid #e1e5e9;
      border-radius: 6px;
      font-size: 12px;
      background: white;
      font-weight: 500;
      transition: border-color 0.2s, box-shadow 0.2s;
    }
    
    .attribute-select:focus {
      outline: none;
      border-color: #18a0fb;
      box-shadow: 0 0 0 3px rgba(24, 160, 251, 0.1);
    }
    
    .attribute-select optgroup {
      font-weight: bold;
      color: #333;
      background-color: #f8f9fa;
      font-size: 11px;
      padding: 4px 0;
    }
    
    .attribute-select option {
      font-weight: normal;
      color: #555;
      padding: 2px 8px;
    }
    
    .save-actions {
      margin-top: 24px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
    }
    
    .save-actions button {
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-weight: 600;
      font-size: 14px;
      padding: 14px 28px;
    }
    
    .save-actions button:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }
    
    .save-actions button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>JSON Attribute Inspector</h2>
    
    <!-- Tab Navigation -->
    <div class="tab-nav">
      <button class="tab-button active" data-tab="tab1">Layer Mapping</button>
      <button class="tab-button" data-tab="tab2">Component Properties</button>
    </div>
    
    <!-- Tab 1: Current functionality -->
    <div class="tab-content active" id="tab1">
      <!-- JSON Input Section -->
    <div class="section">
      <label for="json-input">Paste JSON Data:</label>
      <textarea 
        id="json-input" 
        placeholder='{"name": "John", "age": 30, "city": "New York", "skills": ["JavaScript", "React"]}'
      ></textarea>
      <div id="json-message"></div>
      <button id="apply-json">Apply JSON</button>
    </div>
    
    <!-- Attributes Exploration Section -->
    <div class="section attributes-section" id="attributes-section">
      <!-- Search and Filters -->
      <div class="search-controls">
        <div class="search-box">
          <input type="text" id="attribute-search" placeholder="Search attributes..." style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 12px;">
        </div>
        <div class="filter-controls" style="display: flex; gap: 8px; margin-top: 8px; align-items: center;">
          <select id="type-filter" style="padding: 6px 8px; font-size: 11px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">All Types</option>
            <option value="string">String</option>
            <option value="number">Number</option>
            <option value="boolean">Boolean</option>
            <option value="object">Object</option>
            <option value="array">Array</option>
          </select>
          <select id="category-filter" style="padding: 6px 8px; font-size: 11px; border: 1px solid #ddd; border-radius: 4px;">
            <option value="">All Categories</option>
            <option value="root">Root Level</option>
            <option value="nested">Nested</option>
            <option value="arrays">Arrays</option>
            <option value="primitives">Primitives</option>
          </select>
          <div style="margin-left: auto; font-size: 11px; color: #666;">
            <span id="results-count">0 results</span>
          </div>
        </div>
      </div>
      
      <!-- Attributes Cards -->
      <div id="attributes-cards" class="attributes-cards" style="margin-top: 16px;">
        <!-- Cards will be populated here -->
      </div>
      
      <!-- Selected Attribute Info -->
      <div id="selected-attribute-card" style="display: none; margin-top: 16px; padding: 12px; background: #e8f4fd; border-radius: 8px; border-left: 4px solid #18a0fb;">
        <div style="font-weight: 600; font-size: 12px; color: #333; margin-bottom: 8px;">✅ Selected Attribute</div>
        <div style="font-size: 11px; color: #666;">
          <strong>Path:</strong> <span id="selected-path"></span><br>
          <strong>Value:</strong> <span id="selected-val"></span><br>
          <strong>Type:</strong> <span id="selected-typ"></span>
        </div>
      </div>
    </div>

    <!-- Layer Mapping Section -->
    <div class="section mapping-section" id="mapping-section" style="display: none;">
      <label>🎯 Apply to Selected Layer:</label>
      <div id="layer-info" style="margin-bottom: 12px; padding: 8px; background: #e8f4fd; border-radius: 4px; font-size: 11px;">
        <div id="layer-status">Select a layer on the canvas...</div>
      </div>
      
      <label for="property-select">Apply to Property:</label>
      <select id="property-select">
        <option value="">Choose layer property...</option>
        <option value="text">📝 Text Content</option>
        <option value="fill">🎨 Fill Color (hex)</option>
        <option value="width">📏 Width</option>
        <option value="height">📐 Height</option>
        <option value="x">➡️ X Position</option>
        <option value="y">⬇️ Y Position</option>
        <option value="opacity">👻 Opacity (0-1)</option>
        <option value="rotation">🔄 Rotation (degrees)</option>
        <option value="name">🏷️ Layer Name</option>
      </select>
      
      <div id="mapping-preview" style="display: none; margin: 12px 0; padding: 8px; background: #fff3cd; border-radius: 4px; font-size: 11px;">
        <strong>Preview:</strong> <span id="preview-text"></span>
      </div>
      
      <button id="apply-mapping" disabled>Apply to Layer</button>
      <button id="refresh-selection" style="background: #666; margin-top: 8px;">Refresh Selection</button>
    </div>
    </div>
    
    <!-- Tab 2: Component Property Mapping -->
    <div class="tab-content" id="tab2">
      <!-- Component Selection -->
      <div class="component-selection-section">
        <h3 style="margin: 0 0 8px 0; font-size: 16px; color: #333;">1. Select Component</h3>
        <div class="component-selection">
          <select id="component-select-tab2" class="full-width-select">
            <option value="">Choose a component...</option>
          </select>
        </div>
      </div>
      
      <!-- Property Mapping Section -->
      <div id="property-mapping-section" class="property-mapping-section" style="display: none;">
        <h3 style="margin: 0 0 16px 0; font-size: 16px; color: #333;">2. Map Properties to Attributes</h3>
        <div id="property-mappings-list" class="property-mappings-list">
          <!-- Dynamic property mapping rows will be inserted here -->
        </div>
        
        <!-- Save Actions -->
        <div class="save-actions" style="margin-top: 20px; display: flex; gap: 8px; justify-content: center;">
          <button id="save-component-mapping-tab2" disabled style="background: #18a0fb; color: white; font-weight: 500; padding: 12px 24px;">Save Component Mapping</button>
          <button id="clear-mappings-tab2" disabled style="background: #f24822; color: white; padding: 12px 24px;">Clear Mappings</button>
        </div>
      </div>
      
      <!-- Empty State -->
      <div id="tab2-empty-state" class="empty-state" style="margin: 40px 0; text-align: center; color: #999;">
        <p>Load JSON data in Tab 1, then select a component above to begin mapping.</p>
      </div>
    </div>
  </div>

  <script>
    let currentJsonData = null;
    let attributePaths = [];
    let selectedAttribute = null;
    let currentLayer = null;
    let componentSelectedAttribute = null;
    let availableComponents = [];
    let componentSelectedProperty = null;
    let mappingQueue = [];
    let selectedComponentId = null;

    // Tab switching functionality
    document.querySelectorAll('.tab-button').forEach(button => {
      button.addEventListener('click', (e) => {
        const targetTab = e.target.getAttribute('data-tab');
        switchTab(targetTab);
      });
    });

    function switchTab(tabId) {
      // Update button states
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelector(`[data-tab="${tabId}"]`).classList.add('active');
      
      // Update content visibility
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(tabId).classList.add('active');
      
      // Load components for Tab 2 when switching
      if (tabId === 'tab2') {
        requestComponentsForTab2();
      }
      
      // Reset search filters when switching to tab 1
      if (tabId === 'tab1' && attributePaths.length > 0) {
        document.getElementById('attribute-search').value = '';
        document.getElementById('type-filter').value = '';
        document.getElementById('category-filter').value = '';
        populateAttributeCards();
      }
    }

    // Extract all possible attribute paths from a JSON object
    function extractAttributePaths(obj, prefix = '') {
      const paths = [];
      
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          const currentPath = prefix ? `${prefix}.${key}` : key;
          const value = obj[key];
          
          // Add the current path
          paths.push({
            path: currentPath,
            value: value,
            type: Array.isArray(value) ? 'array' : typeof value
          });
          
          // If it's an object (and not an array), recurse deeper
          if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
            paths.push(...extractAttributePaths(value, currentPath));
          }
          
          // If it's an array, also add paths for array elements
          if (Array.isArray(value)) {
            value.forEach((item, index) => {
              const arrayPath = `${currentPath}[${index}]`;
              paths.push({
                path: arrayPath,
                value: item,
                type: Array.isArray(item) ? 'array' : typeof item
              });
              
              // If array item is an object, recurse into it
              if (typeof item === 'object' && item !== null && !Array.isArray(item)) {
                paths.push(...extractAttributePaths(item, arrayPath));
              }
            });
          }
        }
      }
      
      return paths;
    }

    // Generate statistics about the parsed JSON
    function generateStats() {
      const stats = {
        objects: 0,
        arrays: 0,
        primitives: 0,
        strings: 0,
        numbers: 0,
        booleans: 0,
        nulls: 0
      };
      
      attributePaths.forEach(attr => {
        if (attr.value === null) {
          stats.nulls++;
          stats.primitives++;
        } else {
          switch (attr.type) {
            case 'object':
              stats.objects++;
              break;
            case 'array':
              stats.arrays++;
              break;
            case 'string':
              stats.strings++;
              stats.primitives++;
              break;
            case 'number':
              stats.numbers++;
              stats.primitives++;
              break;
            case 'boolean':
              stats.booleans++;
              stats.primitives++;
              break;
            default:
              stats.primitives++;
          }
        }
      });
      
      return stats;
    }

    // Apply JSON button click handler
    document.getElementById('apply-json').onclick = () => {
      const jsonInput = document.getElementById('json-input').value.trim();
      const messageDiv = document.getElementById('json-message');
      const attributesSection = document.getElementById('attributes-section');
      
      if (!jsonInput) {
        messageDiv.innerHTML = '<div class="error">Please paste some JSON data first.</div>';
        return;
      }
      
      try {
        // Parse the JSON
        currentJsonData = JSON.parse(jsonInput);
        
        // Extract all attribute paths
        attributePaths = extractAttributePaths(currentJsonData);
        
        // Update UI
        const stats = generateStats();
        messageDiv.innerHTML = `
          <div class="success">✅ JSON parsed successfully! Found ${attributePaths.length} attributes.</div>
          <div class="stats">
            <span>📊 ${stats.objects} objects</span>
            <span>📋 ${stats.arrays} arrays</span>
            <span>📝 ${stats.primitives} primitives</span>
          </div>
        `;
        
        // Populate the cards
        populateAttributeCards();
        
        // Show the attributes section
        attributesSection.classList.add('show');
        
      } catch (error) {
        messageDiv.innerHTML = `<div class="error">❌ Invalid JSON: ${error.message}</div>`;
        attributesSection.classList.remove('show');
      }
    };

    let filteredAttributes = [];
    
    function populateAttributeCards() {
      filteredAttributes = [...attributePaths];
      renderAttributeCards(filteredAttributes);
      updateResultsCount(getDisplayCardCount(filteredAttributes));
    }
    
    function renderAttributeCards(attributes) {
      const container = document.getElementById('attributes-cards');
      container.innerHTML = '';
      
      if (attributes.length === 0) {
        container.innerHTML = `
          <div style="padding: 40px; text-align: center; color: #666; font-size: 12px;">
            No attributes match your search criteria
          </div>
        `;
        return;
      }
      
      // Group array items together
      const groupedAttributes = groupArrayItems(attributes);
      
      groupedAttributes.forEach((group) => {
        if (group.isArrayGroup) {
          renderArrayGroupCard(group, container);
        } else {
          renderSingleAttributeCard(group.attr, container);
        }
      });
    }
    
    function groupArrayItems(attributes) {
      const groups = [];
      const arrayGroups = {};
      
      attributes.forEach(attr => {
        // Check if this is an array item (e.g., biomarkers[0].name)
        const arrayMatch = attr.path.match(/^([^[\]]+)\[(\d+)\]/);
        
        if (arrayMatch) {
          const arrayName = arrayMatch[1];
          const index = arrayMatch[2];
          const groupKey = `${arrayName}[${index}]`;
          
          if (!arrayGroups[groupKey]) {
            arrayGroups[groupKey] = {
              isArrayGroup: true,
              arrayName: arrayName,
              index: index,
              basePath: groupKey,
              attributes: []
            };
          }
          
          arrayGroups[groupKey].attributes.push(attr);
        } else {
          // Regular attribute, not in an array
          groups.push({
            isArrayGroup: false,
            attr: attr
          });
        }
      });
      
      // Add array groups to main groups
      Object.values(arrayGroups).forEach(group => {
        groups.push(group);
      });
      
      return groups;
    }
    
    function renderArrayGroupCard(group, container) {
      const card = document.createElement('div');
      card.className = 'attribute-card array-group-card';
      card.dataset.category = 'arrays';
      card.dataset.type = 'object';
      
      // Find the main object value for this array item
      const mainObject = attributePaths.find(attr => attr.path === group.basePath);
      const objectValue = mainObject ? mainObject.value : {};
      
      card.innerHTML = `
        <div class="card-header">
          <div class="card-category">ARRAY ITEM</div>
          <div class="card-type type-object">object</div>
        </div>
        <div class="card-path">${group.basePath}</div>
        <div class="array-properties">
          ${group.attributes.map(attr => {
            const propertyName = attr.path.replace(group.basePath + '.', '');
            return `
              <div class="array-property" data-attr-index="${attributePaths.indexOf(attr)}">
                <span class="property-name">${propertyName}:</span>
                <span class="property-value">${JSON.stringify(attr.value)}</span>
              </div>
            `;
          }).join('')}
        </div>
      `;
      
      // Add click handlers for individual properties
      card.querySelectorAll('.array-property').forEach(propElement => {
        propElement.addEventListener('click', (e) => {
          e.stopPropagation();
          const attrIndex = propElement.dataset.attrIndex;
          const attr = attributePaths[attrIndex];
          selectAttribute(attr, card);
          
          // Highlight the selected property
          card.querySelectorAll('.array-property').forEach(p => p.classList.remove('selected'));
          propElement.classList.add('selected');
        });
      });
      
      container.appendChild(card);
    }
    
    function renderSingleAttributeCard(attr, container) {
      const card = document.createElement('div');
      card.className = 'attribute-card';
      card.dataset.index = attributePaths.indexOf(attr);
      card.dataset.type = attr.type;
      card.dataset.category = getCategoryForAttribute(attr);
      
      const categoryLabel = getCategoryLabel(getCategoryForAttribute(attr));
      const truncatedValue = JSON.stringify(attr.value).length > 80 
        ? JSON.stringify(attr.value).substring(0, 80) + '...'
        : JSON.stringify(attr.value);
      
      card.innerHTML = `
        <div class="card-header">
          <div class="card-category">${categoryLabel}</div>
          <div class="card-type type-${attr.type}">${attr.type}</div>
        </div>
        <div class="card-path">${attr.path}</div>
        <div class="card-value">${truncatedValue}</div>
      `;
      
      card.addEventListener('click', () => selectAttribute(attr, card));
      container.appendChild(card);
    }
    
    function getCategoryForAttribute(attr) {
      if (!attr.path.includes('.') && !attr.path.includes('[')) {
        return 'root';
      } else if (attr.path.includes('[') && !attr.path.includes('.', attr.path.lastIndexOf('['))) {
        return 'arrays';
      } else if (attr.path.includes('.') || attr.path.includes('[')) {
        return 'nested';
      } else {
        return 'primitives';
      }
    }
    
    function getCategoryLabel(category) {
      const labels = {
        root: 'ROOT LEVEL',
        nested: 'NESTED',
        arrays: 'ARRAY ITEM', 
        primitives: 'PRIMITIVE'
      };
      return labels[category] || category.toUpperCase();
    }
    
    function selectAttribute(attr, cardElement) {
      // Remove previous selection from all cards
      document.querySelectorAll('.attribute-card').forEach(card => {
        card.classList.remove('selected');
      });
      
      // Remove previous selection from all array properties
      document.querySelectorAll('.array-property').forEach(prop => {
        prop.classList.remove('selected');
      });
      
      // Add selection to clicked card (but not for array group cards)
      if (!cardElement.classList.contains('array-group-card')) {
        cardElement.classList.add('selected');
      }
      
      // Update selected attribute
      selectedAttribute = attr;
      
      // Update selected attribute info
      document.getElementById('selected-path').textContent = attr.path;
      document.getElementById('selected-val').textContent = JSON.stringify(attr.value);
      document.getElementById('selected-typ').textContent = attr.type;
      document.getElementById('selected-attribute-card').style.display = 'block';
      
      // Show mapping section
      document.getElementById('mapping-section').style.display = 'block';
      
      // Request current layer selection from plugin
      parent.postMessage({ 
        pluginMessage: { 
          type: 'get-selection'
        } 
      }, '*');
      
      // Update mapping preview
      updateMappingPreview();
    }
    
    function updateResultsCount(count) {
      document.getElementById('results-count').textContent = `${count} result${count !== 1 ? 's' : ''}`;
    }

    // Listen for messages from the plugin code
    window.onmessage = (event) => {
      const msg = event.data.pluginMessage;
      if (msg.type === 'layer-selection') {
        currentLayer = msg.layer;
        updateLayerInfo();
      }
      if (msg.type === 'components-list') {
        availableComponents = msg.components;
        populateTab2ComponentsDropdown(msg.components);
      }
      if (msg.type === 'component-properties') {
        displayComponentProperties(msg.properties);
      }
    };

    // Search and filter functionality
    function filterAttributes() {
      const searchTerm = document.getElementById('attribute-search').value.toLowerCase();
      const typeFilter = document.getElementById('type-filter').value;
      const categoryFilter = document.getElementById('category-filter').value;
      
      filteredAttributes = attributePaths.filter(attr => {
        // Search filter
        const matchesSearch = !searchTerm || 
          attr.path.toLowerCase().includes(searchTerm) ||
          JSON.stringify(attr.value).toLowerCase().includes(searchTerm);
        
        // Type filter
        const matchesType = !typeFilter || attr.type === typeFilter;
        
        // Category filter
        let matchesCategory = true;
        if (categoryFilter) {
          if (categoryFilter === 'arrays') {
            // For array filter, include both array objects and their properties
            matchesCategory = attr.path.includes('[') || attr.type === 'array';
          } else {
            matchesCategory = getCategoryForAttribute(attr) === categoryFilter;
          }
        }
        
        return matchesSearch && matchesType && matchesCategory;
      });
      
      renderAttributeCards(filteredAttributes);
      updateResultsCount(getDisplayCardCount(filteredAttributes));
    }
    
    // Count how many cards will be displayed (accounting for grouping)
    function getDisplayCardCount(attributes) {
      const groups = groupArrayItems(attributes);
      return groups.length;
    }
    
    // Add event listeners for search and filters
    document.getElementById('attribute-search').addEventListener('input', filterAttributes);
    document.getElementById('type-filter').addEventListener('change', filterAttributes);
    document.getElementById('category-filter').addEventListener('change', filterAttributes);

    // Property selection handler
    document.getElementById('property-select').onchange = () => {
      updateMappingPreview();
    };

    // Apply mapping button
    document.getElementById('apply-mapping').onclick = () => {
      const property = document.getElementById('property-select').value;
      if (!selectedAttribute || !property || !currentLayer) {
        return;
      }
      
      parent.postMessage({
        pluginMessage: {
          type: 'apply-mapping',
          attribute: selectedAttribute,
          property: property,
          layer: currentLayer
        }
      }, '*');
    };

    // Refresh selection button
    document.getElementById('refresh-selection').onclick = () => {
      parent.postMessage({ 
        pluginMessage: { 
          type: 'get-selection'
        } 
      }, '*');
    };

    // Update layer info display
    function updateLayerInfo() {
      const layerStatus = document.getElementById('layer-status');
      const applyButton = document.getElementById('apply-mapping');
      
      if (currentLayer) {
        layerStatus.innerHTML = `
          <strong>Selected:</strong> ${currentLayer.name} (${currentLayer.type})<br>
          <strong>ID:</strong> ${currentLayer.id}
        `;
        applyButton.disabled = !selectedAttribute || !document.getElementById('property-select').value;
      } else {
        layerStatus.textContent = 'No layer selected. Select a layer on the canvas.';
        applyButton.disabled = true;
      }
      
      updateMappingPreview();
    }

    // Update mapping preview
    function updateMappingPreview() {
      const previewDiv = document.getElementById('mapping-preview');
      const previewText = document.getElementById('preview-text');
      const property = document.getElementById('property-select').value;
      
      if (!selectedAttribute || !property) {
        previewDiv.style.display = 'none';
        return;
      }
      
      let preview = '';
      const value = selectedAttribute.value;
      
      switch (property) {
        case 'text':
          preview = `Set text to: "${value}"`;
          break;
        case 'fill':
          preview = `Set fill color to: ${value}`;
          break;
        case 'width':
          preview = `Set width to: ${value}px`;
          break;
        case 'height':
          preview = `Set height to: ${value}px`;
          break;
        case 'x':
          preview = `Set X position to: ${value}`;
          break;
        case 'y':
          preview = `Set Y position to: ${value}`;
          break;
        case 'opacity':
          preview = `Set opacity to: ${value}`;
          break;
        case 'rotation':
          preview = `Set rotation to: ${value}°`;
          break;
        case 'name':
          preview = `Set layer name to: "${value}"`;
          break;
        default:
          preview = `Apply ${selectedAttribute.path} = ${JSON.stringify(value)}`;
      }
      
      previewText.textContent = preview;
      previewDiv.style.display = 'block';
      
      // Enable/disable apply button
      const applyButton = document.getElementById('apply-mapping');
      applyButton.disabled = !currentLayer;
    }

    // Tab 2 Component-First Functions
    let selectedComponent = null;
    let componentProperties = [];
    let componentMappings = {};
    
    function requestComponentsForTab2() {
      parent.postMessage({ 
        pluginMessage: { 
          type: 'get-components'
        } 
      }, '*');
    }
    
    function populateTab2ComponentsDropdown(components) {
      const select = document.getElementById('component-select-tab2');
      select.innerHTML = '<option value="">Choose a component...</option>';
      
      components.forEach(component => {
        const option = document.createElement('option');
        option.value = component.id;
        option.textContent = component.name;
        select.appendChild(option);
      });
    }
    
    function handleComponentSelection(componentId) {
      if (!componentId) {
        hidePropertyMappingSection();
        return;
      }
      
      // Find selected component
      selectedComponent = availableComponents.find(comp => comp.id === componentId);
      if (!selectedComponent) return;
      
      // Clear previous mappings
      componentMappings = {};
      
      // Request properties for this component
      parent.postMessage({ 
        pluginMessage: { 
          type: 'get-component-properties',
          componentId: componentId
        } 
      }, '*');
    }
    
    function displayComponentProperties(properties) {
      // Filter to only show actual component properties, not text layers
      componentProperties = properties.filter(prop => !prop.name.startsWith('text:'));
      
      if (componentProperties.length === 0) {
        hidePropertyMappingSection();
        return;
      }
      
      showPropertyMappingSection();
      renderPropertyMappingRows();
    }
    
    function showPropertyMappingSection() {
      document.getElementById('property-mapping-section').style.display = 'block';
      document.getElementById('tab2-empty-state').style.display = 'none';
    }
    
    function hidePropertyMappingSection() {
      document.getElementById('property-mapping-section').style.display = 'none';
      document.getElementById('tab2-empty-state').style.display = 'block';
    }
    
    function createSmartAttributeOptions() {
      if (attributePaths.length === 0) {
        return '<option value="">No attributes available</option>';
      }
      
      // Detect arrays and create batch options
      const arrayInfo = detectArrayPatterns();
      
      // Group attributes by their final property name (e.g., "title", "description", etc.)
      const groups = {};
      
      attributePaths.forEach(attr => {
        // Extract the final property name (e.g., "title" from "0.insights[0].title")
        const pathParts = attr.path.split('.');
        const lastPart = pathParts[pathParts.length - 1];
        const propertyName = lastPart.replace(/\[\d+\].*/, '').replace(/\[.*\]/, ''); // Remove array indices
        
        if (!groups[propertyName]) {
          groups[propertyName] = [];
        }
        
        // Create a friendly display name
        let displayName = attr.path;
        let shortValue = JSON.stringify(attr.value);
        
        // Truncate long values and clean up quotes
        shortValue = shortValue.replace(/^"/, '').replace(/"$/, ''); // Remove surrounding quotes
        if (shortValue.length > 40) {
          shortValue = shortValue.substring(0, 37) + '...';
        }
        
        // Make the path more readable
        if (attr.path.includes('[')) {
          // For array items, show which item it is
          const arrayMatch = attr.path.match(/\[(\d+)\]/);
          if (arrayMatch) {
            const itemIndex = parseInt(arrayMatch[1]) + 1; // Convert to 1-based
            displayName = `${propertyName} (Item ${itemIndex})`;
          }
        } else {
          // For simple properties, just show the property name
          displayName = propertyName;
        }
        
        groups[propertyName].push({
          path: attr.path,
          displayName: displayName,
          value: shortValue,
          fullValue: attr.value
        });
      });
      
      // Build grouped options HTML
      let options = '<option value="">Choose attribute...</option>';
      
      // Add batch creation options first
      if (arrayInfo.length > 0) {
        options += '<optgroup label="🚀 BATCH CREATE (Multiple Components)">';
        arrayInfo.forEach(info => {
          options += `<option value="${info.pattern}" data-batch="true" data-count="${info.count}">${info.displayName} (Creates ${info.count} components)</option>`;
        });
        options += '</optgroup>';
      }
      
      // Add regular single-item options
      const sortedGroupNames = Object.keys(groups).sort();
      
      sortedGroupNames.forEach(groupName => {
        const items = groups[groupName];
        
        if (items.length === 1) {
          // Single item, no need for optgroup
          const item = items[0];
          options += `<option value="${item.path}">${item.displayName}: ${item.value}</option>`;
        } else {
          // Multiple items, use optgroup
          options += `<optgroup label="${groupName.toUpperCase()} (Individual Items)">`;
          items.forEach(item => {
            options += `<option value="${item.path}">${item.displayName}: ${item.value}</option>`;
          });
          options += '</optgroup>';
        }
      });
      
      return options;
    }
    
    function detectArrayPatterns() {
      const patterns = {};
      
      attributePaths.forEach(attr => {
        // Look for array patterns like "0.insights[0].title"
        const arrayMatch = attr.path.match(/^(.+?)\[(\d+)\]\.(.+)$/);
        if (arrayMatch) {
          const [, arrayPath, index, property] = arrayMatch;
          const patternKey = `${arrayPath}[*].${property}`;
          
          if (!patterns[patternKey]) {
            patterns[patternKey] = {
              pattern: patternKey,
              arrayPath: arrayPath,
              property: property,
              indices: new Set(),
              sampleValue: attr.value
            };
          }
          
          patterns[patternKey].indices.add(parseInt(index));
        }
      });
      
      // Convert to array and create display info
      return Object.values(patterns).map(pattern => {
        const count = pattern.indices.size;
        const propertyName = pattern.property;
        const arrayName = pattern.arrayPath.split('.').pop();
        
        return {
          pattern: pattern.pattern,
          count: count,
          displayName: `${propertyName} (from ${arrayName} array)`,
          arrayPath: pattern.arrayPath,
          property: pattern.property
        };
      });
    }
    
    function renderPropertyMappingRows() {
      const container = document.getElementById('property-mappings-list');
      container.innerHTML = '';
      
      componentProperties.forEach((property, index) => {
        const row = document.createElement('div');
        row.className = 'property-mapping-row';
        
        // Create attribute dropdown options with smart grouping
        const attributeOptions = createSmartAttributeOptions();
        
        row.innerHTML = `
          <div class="property-info">
            <div class="property-name">${property.name}</div>
            <div class="property-type">${property.type}</div>
          </div>
          <div class="property-arrow">→</div>
          <select class="attribute-select" data-property-name="${property.originalName || property.name}" data-property-original="${property.originalName || property.name}" data-property-display="${property.name}" data-property-type="${property.type}">
            ${attributeOptions}
          </select>
        `;
        
        // Add event listener for dropdown changes
        const select = row.querySelector('.attribute-select');
        select.addEventListener('change', (e) => {
          const originalName = e.target.dataset.propertyOriginal;
          const displayName = e.target.dataset.propertyDisplay;
          handleAttributeSelection(originalName, displayName, e.target.value);
        });
        
        container.appendChild(row);
      });
      
      updateSaveButtons();
    }
    
    function handleAttributeSelection(originalPropertyName, displayPropertyName, attributePath) {
      if (attributePath) {
        // Find the attribute object
        const attribute = attributePaths.find(attr => attr.path === attributePath);
        if (attribute) {
          // Store using original name for backend, but keep display name for reference
          componentMappings[originalPropertyName] = {
            ...attribute,
            displayPropertyName: displayPropertyName
          };
        }
      } else {
        // Remove mapping if no attribute selected
        delete componentMappings[originalPropertyName];
      }
      
      updateSaveButtons();
    }
    
    function updateSaveButtons() {
      const saveButton = document.getElementById('save-component-mapping-tab2');
      const clearButton = document.getElementById('clear-mappings-tab2');
      
      const hasMappings = Object.keys(componentMappings).length > 0;
      saveButton.disabled = !hasMappings;
      clearButton.disabled = !hasMappings;
    }
    
    function clearAllMappings() {
      componentMappings = {};
      
      // Reset all dropdowns
      document.querySelectorAll('.attribute-select').forEach(select => {
        select.value = '';
      });
      
      updateSaveButtons();
    }
    
    function saveComponentMapping() {
      if (Object.keys(componentMappings).length === 0 || !selectedComponent) {
        return;
      }
      
      // Check if any mappings use batch patterns
      const hasBatchMappings = Object.values(componentMappings).some(mapping => 
        mapping.path && mapping.path.includes('[*]')
      );
      
      if (hasBatchMappings) {
        // Calculate array length from the data
        let arrayLength = 0;
        
        for (const [propertyName, mapping] of Object.entries(componentMappings)) {
          if (mapping.path && mapping.path.includes('[*]')) {
            const pattern = mapping.path;
            const arrayPath = pattern.split('[*]')[0];
            
            // Count how many items exist in this array pattern
            const matchingItems = attributePaths.filter(attr => {
              const regex = new RegExp(`^${arrayPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\[\\d+\\]`);
              return regex.test(attr.path);
            });
            
            // Get unique indices
            const indices = new Set();
            matchingItems.forEach(item => {
              const match = item.path.match(/\[(\d+)\]/);
              if (match) {
                indices.add(parseInt(match[1]));
              }
            });
            
            arrayLength = Math.max(arrayLength, indices.size);
          }
        }
        
        // Handle batch creation
        parent.postMessage({
          pluginMessage: {
            type: 'create-batch-components',
            componentId: selectedComponent.id,
            mappings: componentMappings,
            arrayLength: arrayLength,
            attributePaths: attributePaths // Send actual data for mapping
          }
        }, '*');
      } else {
        // Handle single component creation (existing logic)
        const mappings = Object.entries(componentMappings).map(([propertyName, attributeData]) => {
          // Extract just the attribute data without display properties
          const { displayPropertyName, ...attribute } = attributeData;
          return {
            attribute: attribute,
            componentId: selectedComponent.id,
            property: { name: propertyName }
          };
        });
        
        // Send to plugin
        parent.postMessage({
          pluginMessage: {
            type: 'apply-all-component-mappings',
            mappings: mappings
          }
        }, '*');
      }
      
      // Clear mappings after saving
      clearAllMappings();
    }
    
    // Tab 2 Event Handlers
    document.getElementById('component-select-tab2').onchange = (e) => {
      handleComponentSelection(e.target.value);
    };
    
    document.getElementById('save-component-mapping-tab2').onclick = () => {
      saveComponentMapping();
    };
    
    document.getElementById('clear-mappings-tab2').onclick = () => {
      clearAllMappings();
    };

    // Allow pressing Enter in textarea to apply
    document.getElementById('json-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
        document.getElementById('apply-json').click();
      }
    });
  </script>
</body>
</html>